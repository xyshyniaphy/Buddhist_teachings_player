
## **Project Specification: Dharma Stream**

### **Part 2: Backend Specification (Supabase)**

**Version:** 1.3
**Date:** October 21, 2025

---

### **1. Introduction & Philosophy**

The Supabase platform serves as the authoritative backend for the Dharma Stream application. It is the **single source of truth** for all data, permissions, and user identities. The core philosophy is to leverage PostgreSQL's power and security features directly, exposing them through a secure, auto-generated API. All data access rules are enforced at the database level via Row Level Security (RLS), ensuring that no client (frontend or batch worker) can access data it is not permitted to see, regardless of the API key it uses.

### **2. Database Schema Design (`dharma` schema)**

All application-specific tables will reside within a dedicated `dharma` schema to keep them separate from Supabase's internal schemas.

#### **2.1. Core Content Tables**

**Table: `dharma.categories`**
*   **Purpose:** Stores the high-level categories for organizing media content.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `UUID` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` |
| `name` | `TEXT` | `NOT NULL`, `UNIQUE`. The public-facing name of the category. |
| `description` | `TEXT` | `NULLABLE`. A brief description of the category's content. |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. Auditing timestamp. |

**Table: `dharma.media_files`**
*   **Purpose:** Stores the metadata for each audio/video file. Does not store the file itself.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `UUID` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. Crucial for constructing the WebDAV path (`yymm`). |
| `title` | `TEXT` | `NOT NULL`. The title of the teaching. |
| `description` | `TEXT` | `NULLABLE`. A more detailed description or abstract. |
| `speaker` | `TEXT` | `NULLABLE`. The name of the speaker or teacher. |
| `category_id` | `UUID` | `NOT NULL`, `REFERENCES dharma.categories(id) ON DELETE RESTRICT`. Prevents deleting a category that still has media in it. |
| `duration_seconds` | `INT` | `NULLABLE`. To be populated by the batch worker after media processing. |
| `thumbnail_url` | `TEXT` | `NULLABLE`. A public URL to a thumbnail in Supabase Storage. |
| `uploader_id` | `UUID` | `NULLABLE`, `REFERENCES auth.users(id)`. Tracks which admin uploaded the file. |

#### **2.2. Transcription & Correction Tables**

**Table: `dharma.subtitles`**
*   **Purpose:** Stores the individual text segments of a transcription, linked to a media file.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `BIGSERIAL` | `PRIMARY KEY`. Using `BIGSERIAL` for high-volume subtitle entries. |
| `media_id` | `UUID` | `NOT NULL`, `REFERENCES dharma.media_files(id) ON DELETE CASCADE`. If media is deleted, its subtitles are automatically removed. |
| `start_time_ms` | `BIGINT` | `NOT NULL`. The start time of the segment in milliseconds. |
| `end_time_ms` | `BIGINT` | `NOT NULL`. The end time of the segment in milliseconds. |
| `text` | `TEXT` | `NOT NULL`. The original, unaltered text generated by the Whisper STT model. |
| `fixed_text` | `TEXT` | `NULLABLE`. The admin-approved, corrected text. The UI will display this if it exists. |
| `ai_suggest_fix1` | `TEXT` | `NULLABLE`. Placeholder for future AI-driven correction suggestions. |
| `ai_suggest_fix2` | `TEXT` | `NULLABLE`. |
| `ai_suggest_fix3` | `TEXT` | `NULLABLE`. |
*   **Constraints:** `UNIQUE(media_id, start_time_ms)` to prevent duplicate entries for the same timestamp.

**Table: `dharma.user_corrections`**
*   **Purpose:** A log table that captures every correction suggestion submitted by users. This is the input for the admin approval workflow.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `BIGSERIAL` | `PRIMARY KEY`. |
| `subtitle_id` | `BIGINT` | `NOT NULL`, `REFERENCES dharma.subtitles(id) ON DELETE CASCADE`. Links the correction to a specific subtitle line. |
| `corrected_text` | `TEXT` | `NOT NULL`. The new text proposed by the user. |
| `corrector_id` | `UUID` | `NOT NULL`, `REFERENCES auth.users(id)`. Tracks who submitted the correction. |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. |
| `status` | `TEXT` | `NOT NULL`, `DEFAULT 'pending'`. Can be 'pending', 'approved', or 'rejected'. |

#### **2.3. User & Permissions Tables**

**Table: `dharma.user_categories`**
*   **Purpose:** A many-to-many mapping table that grants users access to specific categories. This is the core of the permission model.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `user_id` | `UUID` | `NOT NULL`, `REFERENCES auth.users(id) ON DELETE CASCADE`. Part of the composite primary key. |
| `category_id` | `UUID` | `NOT NULL`, `REFERENCES dharma.categories(id) ON DELETE CASCADE`. Part of the composite primary key. |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. |
| `assigned_by` | `UUID` | `NULLABLE`, `REFERENCES auth.users(id)`. Auditing field for which admin granted access. |
*   **Constraints:** `PRIMARY KEY (user_id, category_id)`.

**Table: `dharma.user_view_history`**
*   **Purpose:** Tracks individual user viewing progress for each media item.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `BIGSERIAL` | `PRIMARY KEY`. |
| `user_id` | `UUID` | `NOT NULL`, `REFERENCES auth.users(id) ON DELETE CASCADE`. |
| `media_id` | `UUID` | `NOT NULL`, `REFERENCES dharma.media_files(id) ON DELETE CASCADE`. |
| `last_viewed_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. Updated on each viewing session. |
| `progress_seconds` | `INT` | `NOT NULL`, `DEFAULT 0`. The last known playback position. |
| `is_finished` | `BOOLEAN` | `NOT NULL`, `DEFAULT false`. |
*   **Constraints:** `UNIQUE (user_id, media_id)`.
*   **Indexes:** `CREATE INDEX idx_user_view_history_user_last_viewed ON dharma.user_view_history (user_id, last_viewed_at DESC);` for efficient querying of a user's recent history.

#### **2.4. Batch Processing Table**

**Table: `dharma.stt_jobs`**
*   **Purpose:** A queue for managing the asynchronous STT and video processing tasks.
*   **Columns:**
| Column Name | Data Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | `UUID` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` |
| `media_id` | `UUID` | `NOT NULL`, `REFERENCES dharma.media_files(id) ON DELETE CASCADE`. |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `DEFAULT now()`. |
| `updated_at` | `TIMESTAMPTZ` | `NULLABLE`. |
| `status` | `job_status` | `NOT NULL`, `DEFAULT 'pending'`. Custom ENUM type: `('pending', 'processing', 'completed', 'failed')`. |
| `error_message` | `TEXT` | `NULLABLE`. Stores error details if the job fails. |
| `processing_started_at` | `TIMESTAMPTZ` | `NULLABLE`. |

### **3. Row Level Security (RLS) Policies**

RLS is enabled on **all** tables in the `dharma` schema. The default policy is DENY. Access is only granted through the explicit policies below.

*   **`dharma.categories`:**
    *   **Policy:** "Allow public read access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.categories FOR SELECT USING (true);`
    *   **Policy:** "Allow admin full access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.categories FOR ALL USING (is_admin(auth.uid()));`

*   **`dharma.media_files`:**
    *   **Policy:** "Allow viewing of media in assigned categories"
    *   **SQL:** `CREATE POLICY "..." ON dharma.media_files FOR SELECT USING (category_id IN (SELECT category_id FROM dharma.user_categories WHERE user_id = auth.uid()));`
    *   **Policy:** "Allow admin full access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.media_files FOR ALL USING (is_admin(auth.uid()));`

*   **`dharma.subtitles`:**
    *   **Policy:** "Allow viewing of subtitles for accessible media"
    *   **SQL:** `CREATE POLICY "..." ON dharma.subtitles FOR SELECT USING (media_id IN (SELECT id FROM dharma.media_files));` (This implicitly chains the RLS policy from `media_files`).
    *   **Policy:** "Allow admin full access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.subtitles FOR ALL USING (is_admin(auth.uid()));`

*   **`dharma.user_corrections`:**
    *   **Policy:** "Allow any authenticated user to submit corrections"
    *   **SQL:** `CREATE POLICY "..." ON dharma.user_corrections FOR INSERT WITH CHECK (auth.role() = 'authenticated' AND corrector_id = auth.uid());`
    *   **Policy:** "Allow admin full access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.user_corrections FOR ALL USING (is_admin(auth.uid()));`

*   **`dharma.user_categories`:**
    *   **Policy:** "Allow users to view their own assignments"
    *   **SQL:** `CREATE POLICY "..." ON dharma.user_categories FOR SELECT USING (auth.uid() = user_id);`
    *   **Policy:** "Allow admin full access"
    *   **SQL:** `CREATE POLICY "..." ON dharma.user_categories FOR ALL USING (is_admin(auth.uid()));`

*   **`dharma.user_view_history`:**
    *   **Policy:** "Allow users to manage their own view history"
    *   **SQL:** `CREATE POLICY "..." ON dharma.user_view_history FOR ALL USING (auth.uid() = user_id);`

### **4. Stored Procedures & Database Functions**

To centralize logic and ensure atomicity, custom PostgreSQL functions will be used.

**Function: `public.is_admin(user_id UUID)`**
*   **Purpose:** A central helper function to check if a user has an admin role. This simplifies RLS policies.
*   **Logic:** This function will check a custom claim in the user's JWT.
*   **SQL:**
    ```sql
    CREATE OR REPLACE FUNCTION public.is_admin(user_id UUID)
    RETURNS BOOLEAN AS $$
    BEGIN
      RETURN (
        SELECT auth.jwt()->>'app_role'
      ) = 'admin' AND user_id = auth.uid();
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```

### **5. API Layer**

#### **5.1. Auto-Generated API (PostgREST)**

Supabase automatically provides a RESTful API for all tables, views, and stored procedures. Access to this API is governed entirely by the RLS policies defined above.

*   **Frontend Usage:** The React frontend will use the `anon_key` to interact with this API. It can only perform actions permitted by the RLS policies for the logged-in user.
*   **Batch Worker Usage:** The Docker workers will use the `service_role_key` to bypass RLS for trusted server-to-server operations, such as inserting subtitles or updating job statuses.

#### **5.2. Custom APIs (Python/FastAPI)**

For complex administrative actions that require orchestration beyond simple database operations, a separate Python API service will be used. This service will be protected and require an admin JWT for access.

*   **`POST /admin/corrections/bulk-process`:** For approving/rejecting corrections in a single transaction.
*   **`POST /admin/users/{user_id}/categories`:** For synchronizing a user's category permissions.
*   **`GET /admin/users/{user_id}/categories`:** For fetching a user's current category permissions.

### **6. Authentication & Authorization (GoTrue)**

*   **Providers:** Email/Password will be the primary authentication method.
*   **Custom JWT Claims:** To power the `is_admin()` function, a custom claim `app_role` will be added to user JWTs. This will be achieved by creating a `dharma.user_roles` table (`user_id`, `role`) and using a trigger on the `auth.users` table to add the claim upon user creation/update.
*   **Roles:**
    *   **`authenticated`:** The default role for any logged-in user.
    *   **`admin`:** A user who has been granted the 'admin' role in the `dharma.user_roles` table. They have full access via RLS policies.

### **7. Environment & Configuration**

The following keys from the Supabase project settings are required by other services:

*   **`SUPABASE_URL`:** The public URL for the Supabase project.
*   **`SUPABASE_ANON_KEY`:** The public, anonymous key. **Safe to expose in the frontend client.**
*   **`SUPABASE_SERVICE_ROLE_KEY`:** The secret service role key. **Must be kept confidential** and used only by the backend services (Batch workers, custom Python API). It bypasses all RLS policies.
